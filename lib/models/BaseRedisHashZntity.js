"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const __1 = require("..");
const RedisManager_1 = require("../microServices/RedisManager");
const LibsExceptions_1 = require("./LibsExceptions");
class BaseRedisHashZntity {
    getBaseZntityId() {
        return this.baseZntityId;
    }
    setBaseZntityId(id) {
        this.baseZntityId = id;
    }
    async execDeleteAll(id) {
        if (!_.isUndefined(id)) {
            throw new LibsExceptions_1.LibsExceptions(__1.BaseHttpStatusCode.STATUS_FAIL, this.constructor.name + 'id is undefined');
        }
        else {
            const redisManger = new RedisManager_1.default();
            const felds = this.deepFeldsKeys();
            const mainKey = this.mainRedisKey() + id;
            let deepValuess = Object.values(felds);
            deepValuess = deepValuess.map((values) => {
                return values + id;
            });
            deepValuess.push(mainKey);
            await redisManger.del(...deepValuess);
        }
    }
    /**
     * 如果要更新的資料太多,可以使用這個
     * 用法就是塞數值之後,會再去判斷有沒有值在幫你塞數值
     * !!!注意第二層的資料是不會幫你處理的,會直接跳過
     * 要處理第二層資料就要自己對redis處理
     * @param {number} id
     * @memberof BaseRedisHashZntity
     */
    async execUpdateRedis(id) {
        if (!_.isUndefined(id)) {
            throw new LibsExceptions_1.LibsExceptions(__1.BaseHttpStatusCode.STATUS_FAIL, this.constructor.name + 'id is undefined');
        }
        else {
            const redisManger = new RedisManager_1.default();
            const felds = this.deepFeldsKeys();
            const mainKey = this.mainRedisKey() + id;
            const deepFelds = Object.entries(felds);
            const promiseList = [];
            const deepValuess = deepFelds.map((data) => {
                return data[0] + id;
            });
            await redisManger.del(...deepValuess);
            let length = deepFelds.length;
            const changeDeepFelds = [];
            while (length--) {
                const feldskey = deepFelds[length][1] + id;
                const feldsName = deepFelds[length][0];
                if (this[feldsName]) {
                    changeDeepFelds.push(feldsName, this[feldsName]);
                    promiseList.push(redisManger.rpush(feldskey, this[feldsName]));
                }
            }
            if (_.size(changeDeepFelds) !== 0) {
                promiseList.push(redisManger.hmgetArray(mainKey, changeDeepFelds));
            }
            await Promise.all(promiseList);
        }
    }
    /**
     * 初始化專用,如果要把資料完整清除在初始化可以用這個
     * @param {number} id
     * @param {*} source
     * @memberof BaseRedisHashZntity
     */
    async execReuseRedis(id, source) {
        if (!_.isUndefined(source)) {
            // 先刪除所有的Redis Keys
            const redisManger = new RedisManager_1.default();
            const felds = this.deepFeldsKeys();
            const deepFelds = Object.entries(felds);
            const mainKey = this.mainRedisKey() + id;
            const mainFields = this.mainFields();
            const deepValuess = deepFelds.map((data) => {
                return data[0] + id;
            });
            deepValuess.push(mainKey);
            await redisManger.del(...deepValuess);
            // 結束 刪除所有的Redis Keys
            // 開始替換主要OBJ的成員把deepFelds裡面的key替換成主要OBJ的成員的數值
            // 並且替換過程中儲存Promise每個deepFelds的成員要塞的數值
            const promiseList = [];
            let length = deepFelds.length;
            const changeDeepFelds = [];
            while (length--) {
                const feldskey = deepFelds[length][1] + id;
                const feldsName = deepFelds[length][0];
                // 儲存Promise每個deepFelds的成員要塞的數值
                promiseList.push(redisManger.rpushArray(feldskey, source[feldsName]));
                changeDeepFelds.push(feldsName, feldskey);
                source[feldsName] = feldskey;
            }
            promiseList.push(redisManger.hmsetArray(mainKey, changeDeepFelds));
            await Promise.all(promiseList);
        }
        else {
            throw new LibsExceptions_1.LibsExceptions(__1.BaseHttpStatusCode.STATUS_FAIL, this.constructor.name + 'source is undefined');
        }
    }
}
exports.default = BaseRedisHashZntity;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFzZVJlZGlzSGFzaFpudGl0eS5qcyIsInNvdXJjZVJvb3QiOiIuL3NyYy8iLCJzb3VyY2VzIjpbIm1vZGVscy9CYXNlUmVkaXNIYXNoWm50aXR5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsNEJBQTRCO0FBQzVCLDBCQUF3QztBQUN4QyxnRUFBd0Q7QUFDeEQscURBQWtEO0FBQ2xELE1BQThCLG1CQUFtQjtJQUd0QyxlQUFlO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztJQUM3QixDQUFDO0lBQ00sZUFBZSxDQUFDLEVBQUU7UUFDckIsSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUtNLEtBQUssQ0FBQyxhQUFhLENBQUMsRUFBVTtRQUNqQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUNwQixNQUFNLElBQUksK0JBQWMsQ0FBQyxzQkFBa0IsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsaUJBQWlCLENBQUMsQ0FBQztTQUN2RzthQUFNO1lBQ0gsTUFBTSxXQUFXLEdBQUcsSUFBSSxzQkFBVyxFQUFFLENBQUM7WUFDdEMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ25DLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsR0FBRyxFQUFFLENBQUM7WUFDekMsSUFBSSxXQUFXLEdBQWEsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNqRCxXQUFXLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO2dCQUNyQyxPQUFPLE1BQU0sR0FBRyxFQUFFLENBQUM7WUFDdkIsQ0FBQyxDQUFDLENBQUM7WUFDSCxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzFCLE1BQU0sV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFdB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dHRwU3RhdHVzQ29kZSB9IGZyb20gJy4uJztcbmltcG9ydCBSZWRpc01hbmdlciBmcm9tICcuLi9taWNyb1NlcnZpY2VzL1JlZGlzTWFuYWdlcic7XG5pbXBvcnQgeyBMaWJzRXhjZXB0aW9ucyB9IGZyb20gJy4vTGlic0V4Y2VwdGlvbnMnO1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgQmFzZVJlZGlzSGFzaFpudGl0eSB7XG5cbiAgICBwcml2YXRlIGJhc2VabnRpdHlJZDtcbiAgICBwdWJsaWMgZ2V0QmFzZVpudGl0eUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlWm50aXR5SWQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXRCYXNlWm50aXR5SWQoaWQpIHtcbiAgICAgICAgdGhpcy5iYXNlWm50aXR5SWQgPSBpZDtcbiAgICB9XG4gICAgcHVibGljIGFic3RyYWN0IG1haW5GaWVsZHMoKTogc3RyaW5nW107XG4gICAgcHVibGljIGFic3RyYWN0IG1haW5SZWRpc0tleSgpOiBzdHJpbmc7XG4gICAgcHVibGljIGFic3RyYWN0IGRlZXBGZWxkc0tleXMoKTogYW55O1xuICAgIHB1YmxpYyBhYnN0cmFjdCBtYWluUmVkaXNUeXBlKCk6IHN0cmluZztcbiAgICBwdWJsaWMgYXN5bmMgZXhlY0RlbGV0ZUFsbChpZDogbnVtYmVyKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChpZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBMaWJzRXhjZXB0aW9ucyhCYXNlSHR0cFN0YXR1c0NvZGUuU1RBVFVTX0ZBSUwsIHRoaXMuY29uc3RydWN0b3IubmFtZSArICdpZCBpcyB1bmRlZmluZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZGlzTWFuZ2VyID0gbmV3IFJlZGlzTWFuZ2VyKCk7XG4gICAgICAgICAgICBjb25zdCBmZWxkcyA9IHRoaXMuZGVlcEZlbGRzS2V5cygpO1xuICAgICAgICAgICAgY29uc3QgbWFpbktleSA9IHRoaXMubWFpblJlZGlzS2V5KCkgKyBpZDtcbiAgICAgICAgICAgIGxldCBkZWVwVmFsdWVzczogc3RyaW5nW10gPSBPYmplY3QudmFsdWVzKGZlbGRzKTtcbiAgICAgICAgICAgIGRlZXBWYWx1ZXNzID0gZGVlcFZhbHVlc3MubWFwKCh2YWx1ZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzICsgaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlZXBWYWx1ZXNzLnB1c2gobWFpbktleSk7XG4gICAgICAgICAgICBhd2FpdCByZWRpc01hbmdlci5kZWwoLi4uZGVlcFZhbHVlc3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWmguaenOimgeabtOaWsOeahOizh+aWmeWkquWkmizlj6/ku6Xkvb/nlKjpgJnlgItcbiAgICAgKiDnlKjms5XlsLHmmK/loZ7mlbjlgLzkuYvlvows5pyD5YaN5Y675Yik5pa35pyJ5rKS5pyJ5YC85Zyo5bmr5L2g5aGe5pW45YC8XG4gICAgICogISEh5rOo5oSP56ys5LqM5bGk55qE6LOH5paZ5piv5LiN5pyD5bmr5L2g6JmV55CG55qELOacg+ebtOaOpei3s+mBjlxuICAgICAqIOimgeiZleeQhuesrOS6jOWxpOizh+aWmeWwseimgeiHquW3seWwjXJlZGlz6JmV55CGXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkXG4gICAgICogQG1lbWJlcm9mIEJhc2VSZWRpc0hhc2habnRpdHlcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZXhlY1VwZGF0ZVJlZGlzKGlkOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IExpYnNFeGNlcHRpb25zKEJhc2VIdHRwU3RhdHVzQ29kZS5TVEFUVVNfRkFJTCwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJ2lkIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVkaXNNYW5nZXIgPSBuZXcgUmVkaXNNYW5nZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZlbGRzID0gdGhpcy5kZWVwRmVsZHNLZXlzKCk7XG4gICAgICAgICAgICBjb25zdCBtYWluS2V5ID0gdGhpcy5tYWluUmVkaXNLZXkoKSArIGlkO1xuICAgICAgICAgICAgY29uc3QgZGVlcEZlbGRzOiBBcnJheTxbc3RyaW5nLCBhbnldPiA9IE9iamVjdC5lbnRyaWVzKGZlbGRzKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VMaXN0OiBBcnJheTxQcm9taXNlPGFueT4+ID0gW107XG4gICAgICAgICAgICBjb25zdCBkZWVwVmFsdWVzcyA9IGRlZXBGZWxkcy5tYXAoKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVswXSArIGlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByZWRpc01hbmdlci5kZWwoLi4uZGVlcFZhbHVlc3MpO1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IGRlZXBGZWxkcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VEZWVwRmVsZHM6IGFueVtdID0gW107XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmZWxkc2tleSA9IGRlZXBGZWxkc1tsZW5ndGhdWzFdICsgaWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZmVsZHNOYW1lID0gZGVlcEZlbGRzW2xlbmd0aF1bMF07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbZmVsZHNOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VEZWVwRmVsZHMucHVzaChmZWxkc05hbWUsIHRoaXNbZmVsZHNOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VMaXN0LnB1c2gocmVkaXNNYW5nZXIucnB1c2goZmVsZHNrZXksIHRoaXNbZmVsZHNOYW1lXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfLnNpemUoY2hhbmdlRGVlcEZlbGRzKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHByb21pc2VMaXN0LnB1c2gocmVkaXNNYW5nZXIuaG1nZXRBcnJheShtYWluS2V5LCBjaGFuZ2VEZWVwRmVsZHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VMaXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiDliJ3lp4vljJblsIjnlKgs5aaC5p6c6KaB5oqK6LOH5paZ5a6M5pW05riF6Zmk5Zyo5Yid5aeL5YyW5Y+v5Lul55So6YCZ5YCLXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAbWVtYmVyb2YgQmFzZVJlZGlzSGFzaFpudGl0eVxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBleGVjUmV1c2VSZWRpcyhpZDogbnVtYmVyLCBzb3VyY2U6IGFueSkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICAgICAgLy8g5YWI5Yiq6Zmk5omA5pyJ55qEUmVkaXMgS2V5c1xuICAgICAgICAgICAgY29uc3QgcmVkaXNNYW5nZXIgPSBuZXcgUmVkaXNNYW5nZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGZlbGRzID0gdGhpcy5kZWVwRmVsZHNLZXlzKCk7XG4gICAgICAgICAgICBjb25zdCBkZWVwRmVsZHM6IEFycmF5PFtzdHJpbmcsIGFueV0+ID0gT2JqZWN0LmVudHJpZXMoZmVsZHMpO1xuICAgICAgICAgICAgY29uc3QgbWFpbktleSA9IHRoaXMubWFpblJlZGlzS2V5KCkgKyBpZDtcbiAgICAgICAgICAgIGNvbnN0IG1haW5GaWVsZHMgPSB0aGlzLm1haW5GaWVsZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZXBWYWx1ZXNzID0gZGVlcEZlbGRzLm1hcCgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhWzBdICsgaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlZXBWYWx1ZXNzLnB1c2gobWFpbktleSk7XG4gICAgICAgICAgICBhd2FpdCByZWRpc01hbmdlci5kZWwoLi4uZGVlcFZhbHVlc3MpO1xuICAgICAgICAgICAgLy8g57WQ5p2fIOWIqumZpOaJgOacieeahFJlZGlzIEtleXNcbiAgICAgICAgICAgIC8vIOmWi+Wni+abv+aPm+S4u+imgU9CSueahOaIkOWToeaKimRlZXBGZWxkc+ijoemdoueahGtleeabv+aPm+aIkOS4u+imgU9CSueahOaIkOWToeeahOaVuOWAvFxuICAgICAgICAgICAgLy8g5Lim5LiU5pu/5o+b6YGO56iL5Lit5YSy5a2YUHJvbWlzZeavj+WAi2RlZXBGZWxkc+eahOaIkOWToeimgeWhnueahOaVuOWAvFxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZUxpc3Q6IEFycmF5PFByb21pc2U8YW55Pj4gPSBbXTtcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBkZWVwRmVsZHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlRGVlcEZlbGRzOiBhbnlbXSA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmVsZHNrZXkgPSBkZWVwRmVsZHNbbGVuZ3RoXVsxXSArIGlkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZlbGRzTmFtZSA9IGRlZXBGZWxkc1tsZW5ndGhdWzBdO1xuICAgICAgICAgICAgICAgIC8vIOWEsuWtmFByb21pc2Xmr4/lgItkZWVwRmVsZHPnmoTmiJDlk6HopoHloZ7nmoTmlbjlgLxcbiAgICAgICAgICAgICAgICBwcm9taXNlTGlzdC5wdXNoKHJlZGlzTWFuZ2VyLnJwdXNoQXJyYXkoZmVsZHNrZXksIHNvdXJjZVtmZWxkc05hbWVdKSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlRGVlcEZlbGRzLnB1c2goZmVsZHNOYW1lLCBmZWxkc2tleSk7XG4gICAgICAgICAgICAgICAgc291cmNlW2ZlbGRzTmFtZV0gPSBmZWxkc2tleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VMaXN0LnB1c2gocmVkaXNNYW5nZXIuaG1zZXRBcnJheShtYWluS2V5LCBjaGFuZ2VEZWVwRmVsZHMpKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VMaXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBMaWJzRXhjZXB0aW9ucyhCYXNlSHR0cFN0YXR1c0NvZGUuU1RBVFVTX0ZBSUwsIHRoaXMuY29uc3RydWN0b3IubmFtZSArICdzb3VyY2UgaXMgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=